Given an input dictionary that is used to construct a recusrive mulitplier architecture 
, we need to make an fstring that has verilog corresponding to that architecture   :- 


r means recursive, and is always following by B...B, where B represents brackets and will describe the structure of the recursive module.
1 recursive module will always have 4 sub-modules, that could be either non-recursive or recursive
nr means non recursive multiplier.



Input : 

rr8x8__B__nr6x6__nr6x2__nr2x6__nr2x2__B__

{(8, 8, 'rr'): {(2, 2, 'nr'): {},
                (2, 6, 'nr'): {},
                (6, 2, 'nr'): {},
                (6, 6, 'nr'): {}}}

Input : rr8x8__B__nr3x3__nr3x5__nr5x3__rr5x5__B__rr4x4__B__rr3x3__B__nr2x2__nr2x1__nr1x2__nr1x1__B__nr3x1__nr1x3__nr1x1__B__nr4x1__nr1x4__nr1x1__B__B__

{(8, 8, 'rr'): {(3, 3, 'nr'): {},
                (3, 5, 'nr'): {},
                (5, 3, 'nr'): {},
                (5, 5, 'rr'): {(1, 1, 'nr'): {},
                               (1, 4, 'nr'): {},
                               (4, 1, 'nr'): {},
                               (4, 4, 'rr'): {(1, 1, 'nr'): {},
                                              (1, 3, 'nr'): {},
                                              (3, 1, 'nr'): {},
                                              (3, 3, 'rr'): {(1, 1, 'nr'): {},
                                                             (1, 2, 'nr'): {},
                                                             (2, 1, 'nr'): {},
                                                             (2, 2, 'nr'): {}}}}}}


The code should be something like this :- 


def rtl_gen(a,b):

    <!-- Modify this code to accomodate all possible f string generator for a module -->

    # a = b = ...,8,6,4,2 if It's an even symmetrical multiplier built re
    if (a == b) and (a % 2 == 0):
        code = f'''
        module exact_symetric__{a}x{a}(input [{a-1}:0] A, input [{a-1}:0] B, output [{2*a-1}:0] P);

            wire [{a//2 - 1}:0] A_H, B_H; 
            wire [{a//2 - 1}:0] A_L, B_L;

            assign A_H = A[{a-1}:{a//2}]; 
            assign A_L = A[{a//2-1}:0];   
            assign B_H = A[{a-1}:{a//2}]; 
            assign B_L = A[{a//2-1}:0];   


            wire [7:0] P1,P2,P3,P4;

            exact_{a//2}x{a//2} M1(.A(A_L), .B(B_L), .P(P1) );
            exact_{a//2}x{a//2} M2(.A(A_H), .B(B_L), .P(P2) );
            exact_{a//2}x{a//2} M3(.A(B_H), .B(A_L), .P(P3) );
            exact_{a//2}x{a//2} M4(.A(B_H), .B(A_H), .P(P4) );

            assign P = (P4 << {a}) + (P3 << {a//2} )  +  (P2 << {a//2} ) + P1 ;

        endmodule
        '''

def dicitonary_parser()
    pass



All non_recusrive multiplier rtl string can be generated by my function called `generate_any_non_recusrive()` which you can append to the main fstring
what you need to do is just make the body of 8x8, along with appending all the sub modules that are required for the COMPLETE RTL

All 3x2, 4x3 ( assymetic multipliers ) are non recursive and the rtl can be generated by my  `generate_any_non_recusrive()`

It's the symmetric recursive multipliers's body that you need to generate

